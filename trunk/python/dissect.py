#!/usr/bin/env python

"""
dissect.py

Cut a timeseries into individual pulses.
* Can be used with:
    - constant period (not implemented yet)
    - polycos (not implemented yet)
    - parfile (not implemented yet)
* Can dump pulses with SNR above given threshold to:
    - .bestprof files (not implemented yet)
    - .dat files (not implemented yet)

Patrick Lazarus, June 16, 2009
"""

import sys
import optparse
import warnings
import numpy as np
import datfile

import ppgplot
# Import matplotlib/pylab and set for non-interactive plots
import matplotlib
matplotlib.use('Agg')
import pylab as plt

# Constants
JOYDIV_SEP = 0.5 # vertical separation per profile in same units 
                  # profiles are plotted in for joydiv plot

parser = optparse.OptionParser(usage="%prog --use-parfile PARFILE | --use-polycos POLYCOFILE | -p --period PERIOD [options] infile.dat", description="Given a input timeseries (a PRESTO .dat file) dissect it into individual pulses and record the pulses that surpass the signification threshold.", version="%prog 0.9")
parser.add_option('-t', '--threshold', dest='threshold', type='float', action='store', help="Only record pulses more significant than this threshold. (Default: 5).", default=5)
parser.add_option('-n', '--no-output-files', dest='create_output_files', action='store_false', help="Do not create any output file for each significant pulse detected. (Default: create output files).", default=True)
parser.add_option('--no-text-files', dest='create_text_files', action='store_false', help="Do not create text file for each significant pulse detected. (Default: create text files).", default=True)
parser.add_option('-s', '--off-pulse-start', dest='off_pulse_start', type='float', help="Define start of off-pulse region. Value should be a float between 0 and 1. (Default: 0.0).", default=0.0)
parser.add_option('-e', '--off-pulse-end', dest='off_pulse_end', type='float', help="Define end of off-pulse region. Value should be a float between 0 and 1. End of off-pulse can be less than start of off-pulse. (Default: 1.0).", default=1.0)

period_group = optparse.OptionGroup(parser, "Period Determination", "The following options are different methods for determine the spin period of the pulsar. Exactly one of these options must be provided.")
period_group.add_option('--use-parfile', dest='parfile', type='string', action='store', help="Determine spin period from polycos generated by tempo using provided parfile.", default=None)
period_group.add_option('--use-polycos', dest='polycofile', type='string', action='store', help="Determine spin period from polycos in the provided file.", default=None)
period_group.add_option('-p', '--use-period', dest='period', type='float', action='store', help="Use constant period provided (in seconds).", default=None)
parser.add_option_group(period_group)

plot_group = optparse.OptionGroup(parser, "Plotting Options", "The following options affect only the output plots, not the data searching.")
plot_group.add_option('-d', '--downsample', dest='downfactor', type='int', action='store', help="Down sample profiles by this factor before plotting. (Default: Don't downsample).", default=1)
parser.add_option('--no-pulse-plots', dest='create_plot_files', action='store_false', help="Do not create plots for each significant pulse detected. (Default: create plots).", default=True)
parser.add_option('--no-joydiv-plot', dest='create_joydiv_plot', action='store_false', help="Do not create Joy Division plot, where every profile is plotted in a single axes separated slightly in the vertical direction. (Default: create JoyDiv plot).", default=True)

parser.add_option_group(plot_group)

options, args = parser.parse_args()

# Count number of period determination options are provided

if (options.parfile is not None) + \
    (options.polycofile is not None) + \
    (options.period is not None) != 1:
    parser.print_usage()
    sys.stderr.write("Exactly one (1) period determination option must be provided! Exiting...\n\n")
    sys.exit(1)
   

def main():
    if options.parfile is not None:
        # generate polycos
        # get periods from polycos
        raise NotImplementedError("--use-parfile option in dissect.py is not implemented yet")
    elif options.polycofile is not None:
        raise NotImplementedError("--use-polycos option in dissect.py is not implemented yet")
    elif options.period is not None:
        get_period = lambda mjd: options.period
    else:
        raise "Unknown option for reading periods!"

    # Open file
    datfn = args[0]
    timeseries = datfile.Datfile(datfn)

    # Loop over pulses in timeseries. Examine pulses one at a time.
    good_pulses = []
    for (pulse_number, current_mjd, current_obstime, \
            current_period, current_pulse) in timeseries.pulses(get_period):
        if is_masked(current_pulse): 
            continue
        if get_snr(current_pulse, options.off_pulse_start, \
                    options.off_pulse_end) > options.threshold:
            good_pulses.append((pulse_number, current_mjd, current_obstime, \
                                current_period, current_pulse))

    print_report(good_pulses)
    if options.create_output_files:
        if options.create_text_files:
            write_pulses(good_pulses, timeseries)
        if options.create_plot_files:
            plot_pulses(good_pulses, timeseries, options.downfactor)
        if options.create_joydiv_plot:
            joy_division_plot2(good_pulses, timeseries.pulses(get_period), \
                            timeseries, options.downfactor, \
                            options.off_pulse_start, options.off_pulse_end)
            # joy_division_plot(good_pulses, timeseries, options.downfactor)


def get_snr(pulse_profile, off_pulse_start=0.0, off_pulse_end=1.0, \
                uncertainty=1):
    """Compute and return statistics about the given pulse.
        Also accepts uncertainty on profile bins. 'uncertainty'
        can be a scalar, or numpy array. 'off_pulse_start' and
        'off_pulse_end' define the off-pulse region. The off-
        pulse region will wrap around if end < start. The
        regions are given in terms of fraction of rotational
        phase.
    """
    # Scale profile
    scaled_profile = scale_profile(pulse_profile, off_pulse_start, off_pulse_end)
    snr = np.max(get_on_pulse(scaled_profile, off_pulse_start, off_pulse_end))
    warnings.warn("Only checking on-pulse region for pulses.")
    return snr


def is_masked(pulse_profile, N=5):
    """Break pulse_profile into 'N' pieces. Check each piece
        if it is flat (max value == min value). If it is then
        return True, profile is partially masked. Otherwise
        return False.
    """
    edges = np.round(np.linspace(0, pulse_profile.size, N+1))
    for i in range(0,N):
        if pulse_profile[edges[i]:edges[i+1]].ptp() == 0:
            # Current section of profile is flat.
            # Profile is partially flat.
            return True
    # No section of profile is flat.
    return False


def get_off_pulse(profile, off_pulse_start, off_pulse_end):
    """Return off-pulse region. 'off_pulse_start' and
        'off_pulse_end' are given in fractions of rotational
        phase (between 0.0 and 1.0).
    """
    off_pulse_start_bin = int(np.round(off_pulse_start*profile.size))
    off_pulse_end_bin = int(np.round(off_pulse_end*profile.size))
    # Determine off pulse region
    if off_pulse_start_bin < off_pulse_end_bin:
        off_pulse_region = profile.copy()[off_pulse_start_bin:off_pulse_end_bin]
    elif off_pulse_start_bin > off_pulse_end_bin:
        off_pulse1 = profile.copy()[off_pulse_start_bin:]
        off_pulse2 = profile.copy()[:off_pulse_end_bin]
        off_pulse_region = np.concatenate((off_pulse1, off_pulse2))
    else:
        # off_pulse_start_bin == off_pulse_end_bin
        # Don't scale profile by stddev
        raise "Off-pulse region is empty!"
    return off_pulse_region 


def get_on_pulse(profile, off_pulse_start, off_pulse_end):
    """Return on-pulse region. 'off_pulse_start' and
        'off_pulse_end' are given in fractions of rotational
        phase (between 0.0 and 1.0).

        ** NOTE: the arguments given define the edges of the 
                _off_ pulse region.
    """
    # Use off_pulse_start/end to get on_pulse_end/start
    on_pulse_start_bin = int(np.round(off_pulse_end*profile.size))
    on_pulse_end_bin = int(np.round(off_pulse_start*profile.size))
    # Determine on pulse region
    if on_pulse_start_bin < on_pulse_end_bin:
        on_pulse_region = profile.copy()[on_pulse_start_bin:on_pulse_end_bin]
    elif on_pulse_start_bin > on_pulse_end_bin:
        # on-pulse region is split
        # It is two halves of two different pulses!
        raise "On-pulse region is split. Will not return two halves of two different pulses!"
    else:
        # on_pulse_start_bin == on_pulse_end_bin
        # on-pulse region is empty
        raise "On-pulse region is empty!"
    return on_pulse_region 


def scale_profile(profile, off_pulse_start=0.0, off_pulse_end=1.0):
    """Subtract profile mean and scale by off-pulse RMS.
        'off_pulse_start' and 'off_pulse_end' define the 
        off-pulse region. The off-pulse region will wrap 
        around if end < start. The regions are given in
        terms of fraction of rotational phase.
    """
    off_pulse_region = get_off_pulse(profile, off_pulse_start, off_pulse_end)
    scaled_profile = np.copy(profile)
    # Do scaling
    off_pulse_mean = np.mean(off_pulse_region)
    scaled_profile -= off_pulse_mean
    # off_pulse_region -= off_pulse_mean # stddev subtracts mean on its own
    scaled_profile /= np.std(off_pulse_region)
    return scaled_profile
    

def print_report(pulses):
    """Print a report given the pulses provided.
        'pulses' is a list where each element is a 5-tuple
        containing the following information:
            - The pulse number of the pulse counting from the start
                of the observation. First pulse number is 1.
            - The MJD of the start of the pulse profile.
            - The time into the observation (in seconds).
            - The duration (in seconds) of the pulse profile.
            - The profile (as a numpy array).
    """
    print "Autopsy report:"
    print "\tNumber of good pulses found: %s" % len(pulses)
    for (num, mjd, time, p, prof) in pulses:
        snr = get_snr(prof, options.off_pulse_start, options.off_pulse_end)
        print "\t#%6d: %10.2f s (SNR: %6.2f)" % (num, time, snr)
   

def plot_pulses(pulses, timeseries, downfactor=1):
    """Plot each pulse into a separate file.
        'pulses' is a list where each element is a 5-tuple
        containing the following information:
            - The pulse number of the pulse counting from the start
                of the observation. First pulse number is 1.
            - The MJD of the start of the pulse profile.
            - The time into the observation (in seconds).
            - The duration (in seconds) of the pulse profile.
            - The profile (as a numpy array).
        Downsample profiles by factor 'downfactor' before plotting.
    """
    for num, mjd, time, p, prof in pulses:
        ds_prof = downsample(prof, downfactor)
        plt.figure()
        plt.plot(ds_prof, 'k-', lw=0.5)
        plt.xlabel("Profile bin")
        plt.title("Pulse #%d" % num)
        plt.savefig("%s.prof%d.ps" % (timeseries.basefn, num), orientation='landscape')


def joy_division_plot(pulses, timeseries, downfactor=1, off_pulse_start=0.0, off_pulse_end=1.0):
    """Plot each pulse profile on the same plot separated
        slightly on the vertical axis.
        'pulses' is a generator/set that returns/contains 5-tuples containing:
            - The pulse number of the pulse counting from the start
                of the observation. First pulse number is 1.
            - The MJD of the start of the pulse profile.
            - The time into the observation (in seconds).
            - The duration (in seconds) of the pulse profile.
            - The profile (as a numpy array).
        'timeseries' is the Datfile object dissected.
        Downsample profiles by factor 'downfactor' before plotting.
        'off_pulse_start' and 'off_pulse_end' define the off-pulse region.
    """
    first = True
    ppgplot.pgbeg("%s.joydiv.ps/CPS" % timeseries.basefn, 1, 1)
    ppgplot.pgpap(10.25, 8.5/11.0)
    ppgplot.pgiden()
    ppgplot.pgsci(1)
    
    # Set up main plot
    ppgplot.pgsvp(0.1, 0.9, 0.1, 0.8)
    ppgplot.pglab("Profile bin", "Single pulse profiles", "")
    to_plot = []
    xmin = 0
    xmax = None
    ymin = None
    ymax = None
    for (num, mjd, T, p, prof) in pulses:
        vertical_offset = (num-1)*JOYDIV_SEP
        ds_prof = scaled_profile(downsample(prof, downfactor), \
                                off_pulse_start, off_pulse_end)
        if first:
            summed_prof = ds_prof.copy()
            first = False
        else:
            summed_prof += ds_prof
        ds_prof += vertical_offset
        min = ds_prof.min()
        if ymin is None or min < ymin:
            ymin = min
        max = ds_prof.max()
        if ymax is None or max > ymax:
            ymax = max
        max = ds_prof.size-1
        if xmax is None or max > xmax:
            xmax = max
        to_plot.append(ds_prof)
    yspace = 0.1*ymax
    ppgplot.pgswin(0, xmax, ymin-yspace, ymax+yspace)
    for prof in to_plot:
        ppgplot.pgline(np.arange(0,prof.size), prof)
    ppgplot.pgbox("BNTS", 0, 0, "BC", 0, 0)

    # Set up summed profile plot
    ppgplot.pgsvp(0.1, 0.9, 0.8, 0.9)
    ppgplot.pglab("", "Summed profile", "Pulses from %s" % timeseries.datfn)
    summed_prof = summed_prof - summed_prof.mean()
    ppgplot.pgswin(0, xmax, summed_prof.min(), summed_prof.max())
    ppgplot.pgline(np.arange(0, summed_prof.size), summed_prof)
    ppgplot.pgbox("C", 0, 0, "BC", 0, 0)
    ppgplot.pgclos()


def joy_division_plot2(good_pulses, all_pulses, timeseries, downfactor=1, \
                                off_pulse_start=0.0, off_pulse_end=1.0):
    """Plot each pulse profile on the same plot separated
        slightly on the vertical axis.
        'good_pulses' and 'all_pulses' are generator/list that
            returns/contains 5-tuples containing:
            - The pulse number of the pulse counting from the start
                of the observation. First pulse number is 1.
            - The MJD of the start of the pulse profile.
            - The time into the observation (in seconds).
            - The duration (in seconds) of the pulse profile.
            - The profile (as a numpy array).
        'timeseries' is the Datfile object dissected.
        Downsample profiles by factor 'downfactor' before plotting.
        'off_pulse_start' and 'off_pulse_end' define the off-pulse region.

        ** Same as joy_division_plot, but sum all profiles between good
            profiles and display with dotted lines. **
    """
    first = True
    ppgplot.pgbeg("%s.joydiv2.ps/CPS" % timeseries.basefn, 1, 1)
    ppgplot.pgpap(10.25, 8.5/11.0)
    ppgplot.pgiden()
    ppgplot.pgsci(1)
    
    # Set up main plot
    ppgplot.pgsvp(0.1, 0.9, 0.1, 0.8)
    ppgplot.pglab("Profile bin", "Single pulse profiles", "")
    to_plot = []
    sums_to_plot = []
    xmin = 0
    xmax = None
    ymin = None
    ymax = None
    # Make a list of good pulse numbers:
    good_nums = [pulse[0] for pulse in good_pulses]
    in_between_pulses_prof = None # Sum of profiles where no pulse is detected
    num_sum = 0
    count = 0
    for (num, mjd, T, p, prof) in all_pulses:
        ds_prof = scale_profile(downsample(prof, downfactor), \
                                off_pulse_start, off_pulse_end)
        if num in good_nums:
            if in_between_pulses_prof is not None:
                # First take care of the in between good pulses sum
                vertical_offset = (float(num_sum)/count)*JOYDIV_SEP
                in_between_pulses_prof = downsample(in_between_pulses_prof, downfactor)
                in_between_pulses_prof = scale_profile(in_between_pulses_prof, \
                                                off_pulse_start, off_pulse_end)
                in_between_pulses_prof += vertical_offset
                min = in_between_pulses_prof.min()
                if ymin is None or min < ymin:
                    ymin = min
                max = in_between_pulses_prof.max()
                if ymax is None or max > ymax:
                    ymax = max
                max = in_between_pulses_prof.size-1
                if xmax is None or max > xmax:
                    xmax = max
                sums_to_plot.append(in_between_pulses_prof)
                num_sum = 0
                count = 0
                in_between_pulses_prof = None
            # Now take care of the good pulse
            vertical_offset = (num-1)*JOYDIV_SEP
            if first:
                summed_prof = ds_prof.copy()
                first = False
            else:
                summed_prof += ds_prof
            ds_prof += vertical_offset
            min = ds_prof.min()
            if ymin is None or min < ymin:
                ymin = min
            max = ds_prof.max()
            if ymax is None or max > ymax:
                ymax = max
            max = ds_prof.size-1
            if xmax is None or max > xmax:
                xmax = max
            to_plot.append(ds_prof)
        else:
            num_sum += num
            count += 1
            scaled_prof = scale_profile(prof, off_pulse_start, off_pulse_end)
            if in_between_pulses_prof is None:
                in_between_pulses_prof = scaled_prof
            else:
                if in_between_pulses_prof.size > scaled_prof.size:
                    in_between_pulses_prof = prof + np.resize(in_between_pulses_prof, scaled_prof.shape)
                elif in_between_pulses_prof.size < scaled_prof.size:
                    in_between_pulses_prof += np.resize(scaled_prof, in_between_pulses_prof.shape)
                else:
                    in_between_pulses_prof += scaled_prof
    # Plot last bit of data
    if in_between_pulses_prof is not None:
        vertical_offset = (float(num_sum)/count)*JOYDIV_SEP
        in_between_pulses_prof = downsample(in_between_pulses_prof, downfactor)
#        in_between_pulses_prof = scale_profile(in_between_pulses_prof, \
#                                        off_pulse_start, off_pulse_end)
        in_between_pulses_prof += vertical_offset
        min = in_between_pulses_prof.min()
        if ymin is None or min < ymin:
            ymin = min
        max = in_between_pulses_prof.max()
        if ymax is None or max > ymax:
            ymax = max
        max = in_between_pulses_prof.size-1
        if xmax is None or max > xmax:
            xmax = max
        sums_to_plot.append(in_between_pulses_prof)
        num_sum = 0
        count = 0
        in_between_pulses_prof = None
    yspace = 0.1*ymax
    ppgplot.pgswin(0, xmax, ymin-yspace, ymax+yspace)
    # Plot good pulses
    for prof in to_plot:
        ppgplot.pgline(np.arange(0,prof.size), prof)
    # Plot partial summed pulses
    ppgplot.pgsci(2)
    for prof in sums_to_plot:
        ppgplot.pgline(np.arange(0,prof.size), prof)
    ppgplot.pgsci(1)
    ppgplot.pgbox("BNTS", 0, 0, "BC", 0, 0)

    # Set up summed profile plot
    ppgplot.pgsvp(0.1, 0.9, 0.8, 0.9)
    ppgplot.pglab("", "Summed profile", "Pulses from %s" % timeseries.datfn)
    summed_prof = summed_prof - summed_prof.mean()
    ppgplot.pgswin(0, xmax, summed_prof.min(), summed_prof.max())
    ppgplot.pgline(np.arange(0, summed_prof.size), summed_prof)
    ppgplot.pgbox("C", 0, 0, "BC", 0, 0)
    ppgplot.pgclos()


def write_pulses(pulses, timeseries):
    """Dump the pulses provided to files.
        'pulses' is a list where each element is a 5-tuple
        containing the following information:
            - The pulse number of the pulse counting from the start
                of the observation. First pulse number is 1.
            - The MJD of the start of the pulse profile.
            - The time into the observation (in seconds).
            - The duration (in seconds) of the pulse profile.
            - The profile (as a numpy array).
        'timeseries' is the Datfile object dissected.
    """
    for num, mjd, time, p, prof in pulses:
        file = open("%s.prof%d" % (timeseries.basefn, num), 'w')
        file.write("# Original data file              = %s\n" % timeseries.datfn)
        file.write("# Pulse Number                    = %d\n" % num)
        file.write("# MJD of start of pulse           = %0.15f\n" % mjd)
        file.write("# Time into observation (seconds) = %f\n" % time)
        file.write("# Duration of pulse (seconds)     = %f\n" % p)
        file.write("# Profile bins                    = %d\n" % len(prof))
        file.write("# Width of profile bin (seconds)  = %g\n" % timeseries.infdata.dt)
        file.write("###################################\n")
        for i, val in enumerate(prof):
            file.write("%-10d %f\n" % (i, val))
        file.close()


def downsample(pulse, downfactor=1):
    """Downsample 'pulse' by adding 'downfactor' adjacent
        bins. ('downfactor' does nothave to be a factor
        of the size of the profile. in this case the end
        of the profile will be truncated.)
    """
    if downfactor > 1:
        pulse = pulse.copy()[:pulse.size/downfactor*downfactor]
        pulse.shape = (pulse.size/downfactor, downfactor)
        pulse = pulse.sum(axis=1)
    return pulse
        

if __name__ == '__main__':
    main()
