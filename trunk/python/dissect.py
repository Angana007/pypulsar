#!/usr/bin/env python

"""
dissect.py

Cut a timeseries into individual pulses.
* Can be used with:
    - constant period
    - polycos (not implemented yet)
    - parfile (not implemented yet)
* Can dump pulses with SNR above given threshold to:
    - .bestprof files (not implemented yet)
    - .dat files (not implemented yet)

Patrick Lazarus, June 16, 2009
"""

import sys
import optparse
import warnings
import numpy as np
import datfile

import ppgplot
# Import matplotlib/pylab and set for non-interactive plots
import matplotlib
matplotlib.use('Agg')
import pylab as plt

# Constants
JOYDIV_SEP = 0.5 # vertical separation per profile in same units 
                  # profiles are plotted in for joydiv plot

parser = optparse.OptionParser(usage="%prog --use-parfile PARFILE | --use-polycos POLYCOFILE | -p --period PERIOD [options] infile.dat", description="Given a input timeseries (a PRESTO .dat file) dissect it into individual pulses and record the pulses that surpass the signification threshold.", version="%prog 0.9")
parser.add_option('-t', '--threshold', dest='threshold', type='float', action='store', help="Only record pulses more significant than this threshold. (Default: 5).", default=5)
parser.add_option('-n', '--no-output-files', dest='create_output_files', action='store_false', help="Do not create any output file for each significant pulse detected. (Default: create output files).", default=True)
parser.add_option('--no-text-files', dest='create_text_files', action='store_false', help="Do not create text file for each significant pulse detected. (Default: create text files).", default=True)
parser.add_option('-s', '--on-pulse-start', dest='on_pulse_start', type='float', help="Define start of on-pulse region. Value should be a float between 0 and 1. (Default: 0.0).", default=0.0)
parser.add_option('-e', '--on-pulse-end', dest='on_pulse_end', type='float', help="Define end of on-pulse region. Value should be a float between 0 and 1. (Default: 1.0).", default=1.0)

period_group = optparse.OptionGroup(parser, "Period Determination", "The following options are different methods for determine the spin period of the pulsar. Exactly one of these options must be provided.")
period_group.add_option('--use-parfile', dest='parfile', type='string', action='store', help="Determine spin period from polycos generated by tempo using provided parfile.", default=None)
period_group.add_option('--use-polycos', dest='polycofile', type='string', action='store', help="Determine spin period from polycos in the provided file.", default=None)
period_group.add_option('-p', '--use-period', dest='period', type='float', action='store', help="Use constant period provided (in seconds).", default=None)
parser.add_option_group(period_group)

plot_group = optparse.OptionGroup(parser, "Plotting Options", "The following options affect only the output plots, not the data searching.")
plot_group.add_option('-d', '--downsample', dest='downfactor', type='int', action='store', help="Down sample profiles by this factor before plotting. (Default: Don't downsample).", default=1)
parser.add_option('--no-pulse-plots', dest='create_plot_files', action='store_false', help="Do not create plots for each significant pulse detected. (Default: create plots).", default=True)
parser.add_option('--no-joydiv-plot', dest='create_joydiv_plot', action='store_false', help="Do not create Joy Division plot, where every profile is plotted in a single axes separated slightly in the vertical direction. (Default: create JoyDiv plot).", default=True)

parser.add_option_group(plot_group)

options, args = parser.parse_args()

# Count number of period determination options are provided

if (options.parfile is not None) + \
    (options.polycofile is not None) + \
    (options.period is not None) != 1:
    parser.print_usage()
    sys.stderr.write("Exactly one (1) period determination option must be provided! Exiting...\n\n")
    sys.exit(1)
   

def main():
    if options.parfile is not None:
        # generate polycos
        # get periods from polycos
        raise NotImplementedError("--use-parfile option in dissect.py is not implemented yet")
    elif options.polycofile is not None:
        raise NotImplementedError("--use-polycos option in dissect.py is not implemented yet")
    elif options.period is not None:
        get_period = lambda mjd: options.period
    else:
        raise "Unknown option for reading periods!"

    # Open file
    datfn = args[0]
    timeseries = datfile.Datfile(datfn)

    # Loop over pulses in timeseries. Examine pulses one at a time.
    good_pulses = []
    for current_pulse in timeseries.pulses(get_period):
        current_pulse.set_onoff_pulse_regions([(options.on_pulse_start, \
                                                options.on_pulse_end)])
        if current_pulse.is_masked(numchunks=5): 
            continue
        for numbins in [1,2,4,8,16,32]:
            pulse = current_pulse.make_copy()
#            pulse.scale()
#            pulse.downsample(numbins)
            pulse.smooth(numbins)
            snr = get_snr(pulse)
            if snr > options.threshold:
                print "Good pulse! #%d, factor=%d (SNR=%f)" % \
                                    (pulse.number, numbins, snr)
                good_pulses.append(current_pulse)
                break

    print_report(good_pulses)
    if options.create_output_files:
        if options.create_text_files:
            write_pulses(good_pulses, timeseries)
        if options.create_plot_files:
            plot_pulses(good_pulses, timeseries, options.downfactor)
        if options.create_joydiv_plot:
            #joy_division_plot2(good_pulses, timeseries.pulses(get_period), \
            #                timeseries, options.downfactor, \
            #                options.on_pulse_start, options.on_pulse_end)
            joy_division_plot(good_pulses, timeseries, options.downfactor)


def get_snr(pulse, uncertainty=1):
    """Compute and return statistics about the given pulse.
        Also accepts uncertainty on profile bins. 'uncertainty'
        can be a scalar, or numpy array.
    """
    # Scale profile
    copy_of_pulse = pulse.make_copy()
    copy_of_pulse.scale()
    snr = np.max(copy_of_pulse.get_on_pulse())
    warnings.warn("Only checking on-pulse region for pulses.")
    return snr


def print_report(pulses):
    """Print a report given the pulses provided.
    """
    print "Autopsy report:"
    print "\tNumber of good pulses found: %s" % len(pulses)
    for pulse in pulses:
        snr = get_snr(pulse)
        print pulse, "(SNR: %f)" % snr
   

def plot_pulses(pulses, timeseries, downfactor=1):
    """Plot each pulse into a separate file.
        Downsample profiles by factor 'downfactor' before plotting.
    """
    for pulse in pulses:
        copy_of_pulse = pulse.make_copy()
        copy_of_pulse.downsample(downfactor)
        plt.figure()
        plt.plot(copy_of_pulse.profile, 'k-', lw=0.5)
        plt.xlabel("Profile bin")
        plt.title("Pulse #%d" % pulse.number)
        plt.savefig("%s.prof%d.ps" % (timeseries.basefn, pulse.number), \
                        orientation='landscape')


def joy_division_plot(pulses, timeseries, downfactor=1):
    """Plot each pulse profile on the same plot separated
        slightly on the vertical axis.
        'timeseries' is the Datfile object dissected.
        Downsample profiles by factor 'downfactor' before plotting.
    """
    first = True
    ppgplot.pgbeg("%s.joydiv.ps/CPS" % timeseries.basefn, 1, 1)
    ppgplot.pgpap(10.25, 8.5/11.0) # Letter landscape
    # ppgplot.pgpap(7.5, 11.7/8.3) # A4 portrait, doesn't print properly
    ppgplot.pgiden()
    ppgplot.pgsci(1)
    
    # Set up main plot
    ppgplot.pgsvp(0.1, 0.9, 0.1, 0.8)
    ppgplot.pglab("Profile bin", "Single pulse profiles", "")
    to_plot = []
    xmin = 0
    xmax = None
    ymin = None
    ymax = None
    for pulse in pulses:
        vertical_offset = (pulse.number-1)*JOYDIV_SEP
        copy_of_pulse = pulse.make_copy()
        copy_of_pulse.downsample(downfactor)
        copy_of_pulse.scale()
        if first:
            summed_prof = copy_of_pulse.profile.copy()
            first = False
        else:
            summed_prof += copy_of_pulse.profile
        prof = copy_of_pulse.profile + vertical_offset
        min = prof.min()
        if ymin is None or min < ymin:
            ymin = min
        max = prof.max()
        if ymax is None or max > ymax:
            ymax = max
        max = prof.size-1
        if xmax is None or max > xmax:
            xmax = max
        to_plot.append(prof)
    yspace = 0.1*ymax
    ppgplot.pgswin(0, xmax, ymin-yspace, ymax+yspace)
    for prof in to_plot:
        ppgplot.pgline(np.arange(0,prof.size), prof)
    ppgplot.pgbox("BNTS", 0, 0, "BC", 0, 0)

    # Set up summed profile plot
    ppgplot.pgsvp(0.1, 0.9, 0.8, 0.9)
    ppgplot.pglab("", "Summed profile", "Pulses from %s" % timeseries.datfn)
    summed_prof = summed_prof - summed_prof.mean()
    ppgplot.pgswin(0, xmax, summed_prof.min(), summed_prof.max())
    ppgplot.pgline(np.arange(0, summed_prof.size), summed_prof)
    ppgplot.pgbox("C", 0, 0, "BC", 0, 0)
    ppgplot.pgclos()


def joy_division_plot2(good_pulses, all_pulses, timeseries, downfactor=1, \
                        on_pulse_start=0.0, on_pulse_end=1.0):
    """Plot each pulse profile on the same plot separated
        slightly on the vertical axis.
        'good_pulses' and 'all_pulses' are generator/list that
            returns/contains Pulse objects. 
        'timeseries' is the Datfile object dissected.
        Downsample profiles by factor 'downfactor' before plotting.
        'on_pulse_start' and 'on_pulse_end' define the on-pulse region
        in terms of rotational phase (between 0.0 and 1.0).

        ** Same as joy_division_plot, but sum all profiles between good
            profiles and display with dotted lines. **
    """
    first = True
    ppgplot.pgbeg("%s.joydiv2.ps/CPS" % timeseries.basefn, 1, 1)
    ppgplot.pgpap(10.25, 8.5/11.0)
    ppgplot.pgiden()
    ppgplot.pgsci(1)
    
    # Set up main plot
    ppgplot.pgsvp(0.1, 0.9, 0.1, 0.8)
    ppgplot.pglab("Profile bin", "Single pulse profiles", "")
    to_plot = []
    sums_to_plot = []
    xmin = 0
    xmax = None
    ymin = None
    ymax = None
    # Make a list of good pulse numbers:
    good_nums = [pulse.number for pulse in good_pulses]
    in_between_pulses_prof = None # Sum of profiles where no pulse is detected
    num_sum = 0
    count = 0
    for pulse in all_pulses:
        pulse.set_onoff_pulse_regions([(on_pulse_start, on_pulse_end)])
        copy_of_pulse = pulse.make_copy()
        copy_of_pulse.downsample(downfactor)
        copy_of_pulse.scale()
        if pulse.number in good_nums:
            if in_between_pulses_prof is not None:
                # First take care of the in between good pulses sum
                vertical_offset = (float(num_sum)/count)*JOYDIV_SEP
                in_between_pulses_prof += vertical_offset
                min = in_between_pulses_prof.min()
                if ymin is None or min < ymin:
                    ymin = min
                max = in_between_pulses_prof.max()
                if ymax is None or max > ymax:
                    ymax = max
                max = in_between_pulses_prof.size-1
                if xmax is None or max > xmax:
                    xmax = max
                sums_to_plot.append(in_between_pulses_prof)
                num_sum = 0
                count = 0
                in_between_pulses_prof = None
            # Now take care of the good pulse
            vertical_offset = (pulse.number-1)*JOYDIV_SEP
            if first:
                summed_prof = copy_of_pulse.profile.copy()
                first = False
            else:
                summed_prof += copy_of_pulse.profile
            prof = copy_of_pulse.profile + vertical_offset
            min = prof.min()
            if ymin is None or min < ymin:
                ymin = min
            max = prof.max()
            if ymax is None or max > ymax:
                ymax = max
            max = prof.size-1
            if xmax is None or max > xmax:
                xmax = max
            to_plot.append(prof)
        else:
            num_sum += pulse.number
            count += 1
            prof = copy_of_pulse.profile.copy()
            if in_between_pulses_prof is None:
                in_between_pulses_prof = prof
            else:
                if in_between_pulses_prof.size > prof.size:
                    in_between_pulses_prof = prof + np.resize(in_between_pulses_prof, prof.shape)
                elif in_between_pulses_prof.size < prof.size:
                    in_between_pulses_prof += np.resize(prof, in_between_pulses_prof.shape)
                else:
                    in_between_pulses_prof += prof
    # Plot last bit of data
    if in_between_pulses_prof is not None:
        vertical_offset = (float(num_sum)/count)*JOYDIV_SEP
        in_between_pulses_prof += vertical_offset
        min = in_between_pulses_prof.min()
        if ymin is None or min < ymin:
            ymin = min
        max = in_between_pulses_prof.max()
        if ymax is None or max > ymax:
            ymax = max
        max = in_between_pulses_prof.size-1
        if xmax is None or max > xmax:
            xmax = max
        sums_to_plot.append(in_between_pulses_prof)
        num_sum = 0
        count = 0
        in_between_pulses_prof = None
    yspace = 0.1*ymax
    ppgplot.pgswin(0, xmax, ymin-yspace, ymax+yspace)
    # Plot partial summed pulses
    ppgplot.pgsci(2)
    for prof in sums_to_plot:
        ppgplot.pgline(np.arange(0,prof.size), prof)
    ppgplot.pgsci(1)
    # Plot good pulses
    for prof in to_plot:
        ppgplot.pgline(np.arange(0,prof.size), prof)
    # Plot boundary of on-pulse region
    ppgplot.pgsls(2)
    ppgplot.pgline(np.array([options.on_pulse_start * prof.size, \
                             options.on_pulse_start * prof.size]), \
                             np.array([ymin,ymax]))
    ppgplot.pgline(np.array([options.on_pulse_end * prof.size, \
                             options.on_pulse_end * prof.size]), \
                             np.array([ymin,ymax]))
    ppgplot.pgsls(1)
    ppgplot.pgbox("BNTS", 0, 0, "BCNTS", 0, 0)

    # Set up summed profile plot
    ppgplot.pgsvp(0.1, 0.9, 0.8, 0.9)
    ppgplot.pglab("", "Summed profile", "Pulses from %s" % timeseries.datfn)
    summed_prof = summed_prof - summed_prof.mean()
    ppgplot.pgswin(0, xmax, summed_prof.min(), summed_prof.max())
    ppgplot.pgline(np.arange(0, summed_prof.size), summed_prof)
    ppgplot.pgbox("C", 0, 0, "BC", 0, 0)
    ppgplot.pgclos()


def write_pulses(pulses, timeseries):
    """Dump the pulses provided to files.
        'timeseries' is the Datfile object dissected.
    """
    for pulse in pulses:
        file = open("%s.prof%d" % (timeseries.basefn, pulse.number), 'w')
        file.write("# Original data file              = %s\n" % timeseries.datfn)
        file.write("# Pulse Number                    = %d\n" % pulse.number)
        file.write("# MJD of start of pulse           = %0.15f\n" % pulse.mjd)
        file.write("# Time into observation (seconds) = %f\n" % pulse.time)
        file.write("# Duration of pulse (seconds)     = %f\n" % pulse.duration)
        file.write("# Profile bins                    = %d\n" % pulse.N)
        file.write("# Width of profile bin (seconds)  = %g\n" % timeseries.infdata.dt)
        file.write("###################################\n")
        for i, val in enumerate(pulse.profile):
            file.write("%-10d %f\n" % (i, val))
        file.close()


if __name__ == '__main__':
    main()
